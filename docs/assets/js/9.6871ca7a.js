(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{274:function(e,t,s){"use strict";s.r(t);var a=s(13),n=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"getting-started"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#getting-started"}},[e._v("#")]),e._v(" Getting Started")]),e._v(" "),t("p",[t("strong",[e._v("Shardcake")]),e._v(" is a "),t("strong",[e._v("Scala open source library")]),e._v(" that makes it easy to distribute entities across multiple servers and interact with those entities using their ID without knowing their actual location (this is also known as "),t("em",[e._v("location transparency")]),e._v(").")]),e._v(" "),t("h2",{attrs:{id:"a-simple-use-case"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#a-simple-use-case"}},[e._v("#")]),e._v(" A simple use case")]),e._v(" "),t("p",[e._v("We are building a multiplayer game where "),t("strong",[e._v("users")]),e._v(" can join "),t("strong",[e._v("guilds")]),e._v(".\nWe expect our game to be successful, so we need to be able to scale out (deploy it on multiple nodes to handle the load).")]),e._v(" "),t("p",[e._v("A guild is limited to 30 members.\nLet's consider the case where 2 users try to join a guild at the exact same time, but our guild already had 29 members.")]),e._v(" "),t("p",[t("img",{attrs:{src:"/shardcake/usecase1.png",alt:"naive diagram"}})]),e._v(" "),t("p",[e._v("If we implement this naively, 2 different nodes might receive our 2 requests to join the guild.\nThey will both check the current size of the guild, which is 29 and accept the new guild member. Now our guild has 31 members ðŸ˜±.")]),e._v(" "),t("p",[e._v("There are 2 common approaches to deal with this issue:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Global lock")]),e._v(" approach: when checking the members of the guild, acquire a lock that is shared between the different game servers, and release it after saving the new member.\nThat way, if 2 different game servers try to do it at the same time, the 2nd one will wait for the first one to finish.")]),e._v(" "),t("li",[t("strong",[e._v("Single writer")]),e._v(" approach: instead of handling the requests on 2 game servers concurrently, redirect the 2 requests to a single entity that will handle them sequentially.")])]),e._v(" "),t("p",[t("strong",[e._v("Entity Sharding")]),e._v(" is a way to implement the second approach. In this case our entities (here, our guilds) will be spread across our game servers so that\neach entity exists in only one place at the time.")]),e._v(" "),t("p",[t("img",{attrs:{src:"/shardcake/usecase2.png",alt:"single writer diagram"}})]),e._v(" "),t("p",[e._v("If our entity might be on any game server, how do we know where it is? This is the second characteristic of entity sharding, known as location transparency: we only need to know the entity ID.\nUsing the entity ID, the sharding system will be able to find on which server the entity is located.")]),e._v(" "),t("p",[t("strong",[e._v("Shardcake")]),e._v(" provides components to:")]),e._v(" "),t("ul",[t("li",[e._v("automatically manage the assignments of entities to game servers")]),e._v(" "),t("li",[e._v("send messages to your entities using their IDs")])]),e._v(" "),t("p",[e._v("Once sharding is setup, it will let you write code like the following:")]),e._v(" "),t("div",{staticClass:"language-scala extra-class"},[t("pre",{pre:!0,attrs:{class:"language-scala"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("def")]),e._v(" joinGuild"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("guildId"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" GuildId"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" ZIO"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("Context"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" Throwable"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" GuildState"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    userId     "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("<-")]),e._v(" getCurrentUserFromContext\n    guildState "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("<-")]),e._v(" guild"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("send"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("guildId"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("JoinGuild"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("userId"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" _"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("yield")]),e._v(" guildState\n")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);